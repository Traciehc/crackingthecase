Welcome back. This is level four, section one, Suspect Sizes, where we're going to be talking about new properties for space‑based size. Up until this point, our flex items have been their default size, but there are times where you're going to want to control the size. In this example, our form, we may want that to grow and use up all of the available space as the screen size grows. Also, to achieve a two‑column layout with spacing, we're going to want to set some defined widths. In our first example, we're dealing with mostly default behavior. I just wanted to share one point that in order to have all the items fit on that very small screen, I had to override Chrome's default behavior and set the min‑width of the input to 0. Aside from that, we can see that our items are only filling up their content space. The flex‑grow property is used to specify the ratio of the space an item should fill in the main axis. It accepts numbers, and its default is 0, 0 meaning don't grow. Here if we set flex‑grow to 0 on all of our inputs, we get our default behavior in that they are their default content size. We can change this default behavior by setting flex‑grow to 1. Here if we put it on just our input, the input is going to grow to take up all of the available space. In this case, the available space is all of the space of the container minus the space necessary for the other flex items. We can also set flex‑grow on multiple properties. If we set flex‑grow to 1 on all three elements, each one is going to try to fill up all the available space that it can. In this case, it means that all three are going to be sharing the space on the flex line. Now we'll look at how things get a little tricky. Since grow is a ratio‑based property, we can use numbers to set the ratio of space that items are supposed to take. Here we have three divs. We're setting our flex‑grow of 1 on two of them and a flex‑grow of 2 on the third. That gives us four units of space for the divs to divide. In a perfect world in a 1000‑pixel container, our element set to 2 is going to take up 500 pixels, and each of the elements set to 1 are going to take up 250 pixels. As we change content, things continue to change more drastically. By just changing the number of characters in each div, now our one‑unit ratio elements are no longer the same size, they are 279 pixels and 288 pixels. This is something to know going forward if you're trying to create layouts using ratio‑based flex‑grow. If you want defined widths for items, you're going to want a different solution, which we'll get to later. In this example, we'll look at a different problem in that we don't want an item to get smaller than it is. As the screen size changes here, you can see that our image is getting continuously smaller, almost to the point of not being able to see it anymore. The flex‑shrink property is used to specify the shrink factor of an item. It accepts numbers, and its default is 1, which means do shrink. So here, if we change our value to 0, the item containing the image won't change size even if it ends up bigger than the other items sharing the space. Here's our flex‑shrink 0 zero in action. As the screen size gets smaller, the image stays the same size and the other flex item adjusts to fill the remaining space. Now it's your turn to have items grow and shrink using Flexbox in the challenges.

Autoscroll